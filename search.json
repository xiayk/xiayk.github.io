[{"title":"微信小程序-Java (模板消息)","url":"/2019/08/25/微信小程序-java-模板消息/","content":"### 微信小程序模板消息\n- 请求地址(POST)\n\t`https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=TOKEN`\n- 请求参数\n\t```json\n    {\n    \t\"template_id\": \"模板Id (XXXX)\",\n        \"touser\": \"接收用户的openId (XXXX)\",\n        \"page\": \"点击模板消息跳转页面 (pages/index?data=XX)\",\n        \"data\": \n        {\n        \t\"keyword1\": {\"value\": \"\"},\n            \"keyword2\": {\"value\": \"\"},\n            \"keyword3\": {\"value\": \"\"},\n            ...\n        }\n    }\n    ```\n\n#### 获取access_token\n```java\n/**\n * 获取微信access_token\n * @return\ttoken\n */\npublic String getToken(){\n        String token;\n        try {\n        \t//获取redis中token\n            token = redisTemplate.opsForValue().get(\"access_token\");\n            if (token == null) {\n                throw new Exception();\n            }\n        }catch (Exception e){\n        \t//重新获取token\n            String url = String.format(\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=%s&secret=%s\",appId, appsecret);\n            token = JSONObject.parseObject(Utils.doGet(url)).getString(\"access_token\");\n           //存入redis  7200s 2小时过期 redisTemplate.opsForValue().set(\"access_token\", token, 7200, TimeUnit.SECONDS);\n        }\n        return token;\n    }\n```\n\n#### 发送模板消息\n```java\n//请求地址\nString url = String.format(\"https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=%s\", token);\n\n//请求参数\nJSONObject jsonObject = new JSONObject();\njsonObject.put(\"template_id\", templateId);\njsonObject.put(\"form_id\", formId);\njsonObject.put(\"touser\", toUser);\njsonObject.put(\"page\", pagePath);\n\n//data\nJSONObject jsonData = new JSONObject();\nJSONObject json1 = new JSONObjectect();\njson1.put(\"value\", \"\");\njsonData.put(\"keyword1\", json1);\nJSONObject json2 = new JSONObject();\njson2.put(\"value\", \"\");\njsonData.put(\"keyword2\", json2);\nJSONObject json3 = new JSONObject();\njson3.put(\"value\", \"\");\njsonData.put(\"keyword3\", json3);\nJSONObject json4 = new JSONObject();\njson4.put(\"value\", \"\");\njsonData.put(\"keyword4\", json4);\n\njsonObject.put(\"data\", jsonData);\n\ndoPost(jsonObject.toJSONString(), url);\n```","tags":["小程序","java"],"categories":["小程序","java"]},{"title":"Springboot集成jwt实现token验证","url":"/2019/06/28/springboot集成jwt实现token验证/","content":"#### 什么是JWT\nJson web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。\n\n#### JWT请求流程\n<image src=\"http://file.xiayk.com/4630295-7df0d10fcffe831b.png\"/>\n\n1. 用户使用账号和面发出post请求；\n2. 服务器使用私钥创建一个jwt；\n3. 服务器返回这个jwt给浏览器；\n4. 浏览器将该jwt串在请求头中像服务器发送请求；\n5. 服务器验证该jwt；\n6. 返回响应的资源给浏览器。\n\n#### 代码\nJwtConfig.java\n创建token  存入redis 设置token过时间, 如果在规定时间内没有验证token redis就会删除token\n```java\n/**\n* 根据微信用户登陆信息创建 token\n* 注 : 这里的token会被缓存到redis中,用作为二次验证\n* redis里面缓存的时间应该和jwt token的过期时间设置相同\n*\n* @param wxRes 微信用户信息\n* @return 返回 jwt token\n*/\npublic String createTokenByWxAccount(WxRes wxRes) {\n        String jwtId = UUID.randomUUID().toString();                 //JWT 随机ID,做为验证的key\n        //1 . 加密算法进行签名得到token\n        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);\n        String token = JWT.create()\n                .withClaim(\"wxOpenId\", wxRes.getWxopenid())\n                .withClaim(\"sessionKey\", wxRes.getSessionkey())\n                .withClaim(\"jwt-id\", jwtId)\n                .withExpiresAt(new Date(System.currentTimeMillis() + expire_time*1000))  //JWT 配置过期时间的正确姿势\n                .sign(algorithm);\n        //2 . Redis缓存JWT, 注 : 请和JWT过期时间一致\n        redisTemplate.opsForValue().set(\"JWT-SESSION-\" + jwtId, token, expire_time, TimeUnit.SECONDS);\n        return token;\n    }\n```\n验证token redis给token续期\n```java\n /**\n  * 校验token是否正确\n  * 1 . 根据token解密，解密出jwt-id , 先从redis中查找出redisToken，匹配是否相同\n  * 2 . 然后再对redisToken进行解密，解密成功则 继续流程 和 进行token续期\n  *\n  * @param token 密钥\n  * @return 返回是否校验通过\n  */\n public boolean verifyToken(String token) {\n     try {\n         //1 . 根据token解密，解密出jwt-id , 先从redis中查找出redisToken，匹配是否相同\n         String redisToken = redisTemplate.opsForValue().get(\"JWT-SESSION-\" + getJwtIdByToken(token));\n          if (!redisToken.equals(token)) return false;\n          //2 . 得到算法相同的JWTVerifier\n          Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);\n          JWTVerifier verifier = JWT.require(algorithm)\n                  .withClaim(\"wxOpenId\", getWxOpenIdByToken(redisToken))\n                  .withClaim(\"sessionKey\", getSessionKeyByToken(redisToken))\n                  .withClaim(\"jwt-id\", getJwtIdByToken(redisToken))\n                  .acceptExpiresAt(System.currentTimeMillis() + expire_time*1000 )  //JWT 正确的配置续期姿势\n                  .build();\n          //3 . 验证token\n          verifier.verify(redisToken);\n          //4 . Redis缓存JWT续期\n          redisTemplate.opsForValue().set(\"JWT-SESSION-\" + getJwtIdByToken(token), redisToken, expire_time, TimeUnit.SECONDS);\n          return true;\n      } catch (Exception e) { //捕捉到任何异常都视为校验失败\n          return false;\n      }\n  }\n```\n\n拦截器\n```java\n/**\n * 拦截器  token\n * @ClassName LoginInterceptor\n * @Author XiaYk\n * @Date 2019-06-23 22:06\n * @Version 1.0\n */\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);\n\n    @Autowired\n    private WxResService service;\n\n    private String notloginRes = JSONObject.toJSONString(new RestResult(false, -1, \"\", \"未登录\"));\n    private String errRes = JSONObject.toJSONString(new RestResult(false, -2, \"\", \"登录过期, 请重新登录\"));\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json; charset=utf-8\");\n        response.setHeader(\"Access-control-Allow-Origin\", request.getHeader(\"Origin\"));\n        response.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,PUT,DELETE\");\n        response.setHeader(\"Access-Control-Allow-Headers\", request.getHeader(\"Access-Control-Request-Headers\"));\n        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态\n        if (request.getMethod().equals(RequestMethod.OPTIONS.name())) {\n            response.setStatus(HttpStatus.OK.value());\n            return false;\n        }\n        //获取访问URL\n        String url = request.getRequestURL().toString();\n        String token = request.getHeader(\"XWEB_TOKEN\");\n\n        if (token == null){\n            PrintWriter out = response.getWriter();\n            out.append(notloginRes);\n            return false;\n        }\n\n        if (service.verifyToken(token)){\n            logger.info(\"url ====> {}  token ====> {}\", url, token);\n            return true;\n        }else {\n            logger.info(\"token 过期\");\n            PrintWriter out = response.getWriter();\n            out.println(errRes);\n            return false;\n        }\n    }\n\n    /**\n     * // 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）\n     * @param request\n     * @param response\n     * @param handler\n     * @param modelAndView\n     * @throws Exception\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    /**\n     * 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n```java\n/**\n * @ClassName MyWebAppConfigurer\n * @Author XiaYk\n * @Date 2019-06-24 00:21\n * @Version 1.0\n */\n@Configuration\npublic class MyWebAppConfigurer extends WebMvcConfigurationSupport {\n\n    @Bean\n    LoginInterceptor interceptor() {\n        return new LoginInterceptor();\n    }\n\n    @Override\n    protected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        super.configureMessageConverters(converters);\n    }\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        registry.addInterceptor(interceptor()).addPathPatterns(\"/wx/**\")//拦截\n                .excludePathPatterns(\"/wx/login\").excludePathPatterns(\"/getData\");//开放\n    }\n}\n```\n然后在controller调用 获取token 返回给前端\n```java\n/**\n * 登录\n * @param code\n * @return\n */\n@PostMapping(\"login\")\npublic RestResult wxLogin(@RequestParam(\"code\") String code){\n    String token = wxResService.selectByCode(code);\n    Map<String, Object> map = new HashMap<>();\n    map.put(\"token\", token);\n    map.put(\"username\", \"XiaYk\");\n    return new RestResult(true, 200, map, \"\");\n}\n```\npom.xml\n```xml\n<!--springboot-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<!--redis-->\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n<!--JWT-->\n<dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>java-jwt</artifactId>\n    <version>3.4.1</version>\n</dependency>\n```","tags":["springboot","java","jwt"],"categories":["java"]},{"title":"微信小程序-Java (登录)","url":"/2019/05/10/微信小程序-Java-登录/","content":"\n[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html)\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n\n\n### 一,Java后端\n接收小程序端传过来的code;\n```java\n\t/**\n     * 微信登录\n     * @param code\n     * @return\n     */\n    @RequestMapping(value = \"/login\")\n    public RestResult wxlogin(@RequestParam(\"code\") String code){\n\n        //获取openid\n        JSONObject jsonObject = WxUtil.getSessionKeyOropenid(code);\n        String openid = jsonObject.get(\"openid\").toString();\n        System.out.println(code);\n        WxUserInfoKey wxUserInfoKey = new WxUserInfoKey();\n        wxUserInfoKey.setOpenid(openid);\n        WxUserInfo info = wxUserInfoService.selectByPrimaryKey(wxUserInfoKey);\n\n        if (info == null){\n            throw new MyException(-1, \"未绑定账户\");\n        }\n\n        UserKey key = new UserKey();\n        key.setUsername(info.getUsername());\n        User user = userService.selectByPrimaryKey(key);\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword());\n        subject.login(token);\n        return new RestResult(true,0,info,\"mes: ok\");\n\n    }\n```\n\n\nWeChat工具类/获取openid\n```java\npackage com.xiayk.utils;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.codehaus.xfire.util.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.UnsupportedEncodingException;\nimport java.security.*;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.ResourceBundle;\n\n/**\n * @ClassName WxUtil\n * @Author XiaYk\n * @Date 2019-04-26 19:08\n * @Version 1.0\n */\npublic class WxUtil {\n    Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 获取微信小程序 session_key 和 openid\n     *\n     * @author zhy\n     * @param code 调用微信登陆返回的Code\n     * @return\n     */\n    public static JSONObject getSessionKeyOropenid(String wxCode){\n        String requestUrl = \"https://api.weixin.qq.com/sns/jscode2session\";//resource.getString(\"url\"); //请求地址 https://api.weixin.qq.com/sns/jscode2session\n        Map<String,String> requestUrlParam = new HashMap<>();\n        requestUrlParam.put(\"appid\", \"*************\"); //开发者设置中的appId\n        requestUrlParam.put(\"secret\", \"***********************\"); //开发者设置中的appSecret\n        requestUrlParam.put(\"js_code\", wxCode); //小程序调用wx.login返回的code\n        requestUrlParam.put(\"grant_type\", \"authorization_code\");  //默认参数\n\n        //发送post请求读取调用微信 https://api.weixin.qq.com/sns/jscode2session 接口获取openid用户唯一标识\n        JSONObject jsonObject = JSON.parseObject(UrlUtil.sendPost(requestUrl, requestUrlParam));\n        return jsonObject;\n    }\n\n    /**\n     * 解密用户敏感数据获取用户信息\n     *\n     * @author zhy\n     * @param sessionKey 数据进行加密签名的密钥\n     * @param encryptedData 包括敏感数据在内的完整用户信息的加密数据\n     * @param iv 加密算法的初始向量\n     * @return\n     */\n    public static JSONObject getUserInfo(String encryptedData,String sessionKey,String iv){\n        // 被加密的数据\n        byte[] dataByte = Base64.decode(encryptedData);\n        // 加密秘钥\n        byte[] keyByte = Base64.decode(sessionKey);\n        // 偏移量\n        byte[] ivByte = Base64.decode(iv);\n        try {\n            // 如果密钥不足16位，那么就补足. 这个if 中的内容很重要\n            int base = 16;\n            if (keyByte.length % base != 0) {\n                int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0);\n                byte[] temp = new byte[groups * base];\n                Arrays.fill(temp, (byte) 0);\n                System.arraycopy(keyByte, 0, temp, 0, keyByte.length);\n                keyByte = temp;\n            }\n            // 初始化\n            Security.addProvider(new BouncyCastleProvider());\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");\n            SecretKeySpec spec = new SecretKeySpec(keyByte, \"AES\");\n            AlgorithmParameters parameters = AlgorithmParameters.getInstance(\"AES\");\n            parameters.init(new IvParameterSpec(ivByte));\n            cipher.init(Cipher.DECRYPT_MODE, spec, parameters);// 初始化\n            byte[] resultByte = cipher.doFinal(dataByte);\n            if (null != resultByte && resultByte.length > 0) {\n                String result = new String(resultByte, \"UTF-8\");\n                return JSON.parseObject(result);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            } catch (NoSuchPaddingException e) {\n        } catch (InvalidParameterSpecException e) {\n        } catch (IllegalBlockSizeException e) {\n        } catch (BadPaddingException e) {\n        } catch (UnsupportedEncodingException e) {\n        } catch (InvalidKeyException e) {\n        } catch (InvalidAlgorithmParameterException e) {\n        } catch (NoSuchProviderException e) {\n        }\n        return null;\n    }\n}\n\n```\n\n\n\n","tags":["Java","wechat","springboot","小程序"],"categories":["java"]},{"title":"Linux下Nginx+Tomcat整合配置","url":"/2019/05/05/Linux下Nginx-Tomcat整合配置/","content":"\n#### 一, 安装jdk和tomcat\n1, jdk安装 \njdk的话,我直接用的yum安装的,简单方便\n```\nyum list java-1.8*\nyum install java-1.8*\n```\n安装完检查jdk\n```\njava -version\n```\n安装成功后就可以开始安装tomcat了\n\n2, tomcat安装\n先去tomcat官网  找到自己需要的版本 下载那个`tar.gz`后缀的\n我用的[tomcat官网](http://tomcat.apache.org)\n然后在服务器上\n```\n//下载\nwget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.40/bin/apache-tomcat-8.5.40.tar.gz\n//解压\ntar -zxvf apache-tomcat-8.5.40.tar.gz\n```\n下载完解压然后测试一下\n```\n//运行\n./apache-tomcat-8.5.40.tar.gz/bin/start.sh\n```\n访问一下`ip:8080`如能成功显示tomcat页面就行了\n如不能访问,先看一下tomcat日志\n```\ncat apache-tomcat-8.5.40/logs/catalina.out\n```\n一般应该是没问题的, 看一下8080端口是否开放\n```\nps -ef| grep tomcat\n```\n这个可以看tomcat进程\n没问题的话  就可以开始下一步了\n\n#### 二, Nginx安装和配置\nnginx我也是刚开始来了解, 可能配置得不是很专业\n[nginx官网](http://nginx.org)\n```\n//下载\nwget http://nginx.org/download/nginx-1.14.2.tar.gz\n//解压\ntar -zxvf nginx-1.14.2.tar.gz\n```\n80端口配置\n```\nserver {\n        listen       80;\n        server_name  xiayk.cn; #域名\n        index index.html index.htm;\n        location / {\n           root   html; #站点目录\n        }\n    }\n    server {\n        listen       80;\n        server_name  api.xiayk.cn;\n        index index.html index.htm index.jsp;\n        location / {\n           proxy_pass http://127.0.0.1:8080/api;\n        }\n    }\n```\n\n443端口配置\n```\nserver {\n     listen 443;\n     server_name xiayk.cn; #填写绑定证书的域名\n     ssl on;\n     ssl_certificate /usr/local/nginx/conf/ssl/www/1_xiayk.cn_bundle.crt;\n     ssl_certificate_key /usr/local/nginx/conf/ssl/www/2_xiayk.cn.key;\n     ssl_session_timeout 5m;\n     ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n     ssl_prefer_server_ciphers on;\n     location / {\n         root   html; #站点目录\n         index  index.html index.htm;\n     }\n   }\n```\n\n\n\n\n\n","tags":["Linux","nginx","tomcat"],"categories":["Linux"]},{"title":"我的第一篇博客","url":"/2019/05/02/我的第一篇博客/"},{"title":"Hello World","url":"/2019/05/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]