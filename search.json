[{"title":"Springboot[全局异常处理]","url":"/2020/04/07/springboot-全局异常处理/","content":"\n### springboot全局异常处理\n\n##### 注解 (异常捕获)\n`@RestControllerAdvice` = `@ControllerAdvice` + `@ResponseBody`\n\n```java\n/**\n *\n * token异常\n */\npublic class TokenException extends RuntimeException {\n\n\t\n\tprivate static final long serialVersionUID = 1443386052898280663L;\n\n\tpublic TokenException(String msg){\n\t\tsuper(msg);\n\t}\n\t\n}\n```\n\n##### 异常处理\n```java\n/**\n * Created with IDEA\n * Description:\n *\n * @Auther: xiayk\n * @date: 2020/04/03 下午7:53\n **/\n@Slf4j\n@RestControllerAdvice\npublic class ExceptionHandler {\n\n  /**\n   * TokenException 类捕获\n   */\n  @ExceptionHandler(value = TokenException.class)\n  public Result handler(TokenException e) {\n    log.error(e.getMessage(), e);\n    return Result.ofFail(401, e.getMessage());\n  }\n  \n  /**\n   * UserException 类捕获\n   */\n  @ExceptionHandler(value = UserException.class)\n  public Result handler(UserException e) {\n    log.error(e.getMessage(), e);\n    return Result.ofFail(e.getCode(), e.getMessage());\n  }\n}\n```\n\n##### 程序主动抛出异常\n```java\n// 判断是否有权限抛出异常\nthrow new TokenException(\"Token过期\");\n```","tags":["Java","springboot"],"categories":["Java"]},{"title":"Springboot[二维码扫码登录]","url":"/2020/04/07/springboot-二维码扫码登录/","content":"\n\n### springboot扫码登录功能\n\n二维码扫码登陆的原理。先上二维码扫码登录的流程图：\n![流程图](/images/blog_3/171333eac05db6cb.png)\n\n1. PC端访问后台接口生成登录二维码,UUID存入redis;`{key:UUID,value:0}`\n2. PC端定时器轮询二维码状态,是否扫码/确认;\n3. 手机端扫码,解析二维码,提交到服务器;\n4. 后台获取扫码用户token和传入UUID,解析token获取uid存入redis`{key:UUID,value:uid}`, 验证接口返回扫码成功,等待确认登录;\n5. 手机端确认登录 ,PC端轮询 - 已确认,生成PC端token;\n\n\nPC 端接受到二维码 ID 之后，将二维码 ID 以二维码的形式展示获取直接返回byte[]，等待移动端扫码。此时在 PC 端会启动一个定时器，轮询查询二维码的状态。如果移动端未扫描的话，那么一段时间后二维码将会失效(redis中设置过期时间)。\n\n### 源码\n[GITEE](https://gitee.com/xiayk/xweb-demo/tree/master/qrcode)\n\n[GIHUB](https://github.com/xiayk/xweb-demo/tree/master/qrcode)\n","tags":["Java","springboot"],"categories":["Java"]},{"title":"Git常用命令","url":"/2020/04/04/Git常用命令/","content":"\n```\ngit branch 查看本地所有分支\n\ngit status 查看当前状态\n\ngit commit 提交\n\ngit branch -a 查看所有的分支\n\ngit branch -r 查看远程所有分支\n\ngit commit -am \"init\" 提交并且加注释\n\ngit remote add origin git@192.168.1.119:ndshow\n\ngit push origin master 将文件给推到服务器上\n\ngit remote show origin 显示远程库origin里的资源\n\ngit push origin master:develop\n\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联\n\ngit checkout --track origin/dev 切换到远程dev分支\n\ngit branch -D master develop 删除本地库develop\n\ngit checkout -b dev 建立一个新的本地分支dev\n\ngit merge origin/dev 将分支dev与当前分支进行合并\n\ngit checkout dev 切换到本地dev分支\n\ngit remote show 查看远程库\n\ngit add .\n\ngit rm 文件名(包括路径) 从git中删除指定文件\n\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\n\ngit config --list 看所有用户\n\ngit ls-files 看已经被提交的\n\ngit rm [file name] 删除一个文件\n\ngit commit -a 提交当前repos的所有的改变\n\ngit add [file name] 添加一个文件到git index\n\ngit commit -v 当你用－v参数的时候可以看commit的差异\n\ngit commit -m \"This is the message describing the commit\" 添加commit信息\n\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\n\ngit commit -a -v 一般提交命令\n\ngit log 看你commit的日志\n\ngit diff 查看尚未暂存的更新\n\ngit rm a.a 移除文件(从暂存区和工作区中删除)\n\ngit rm --cached a.a 移除文件(只从暂存区中删除)\n\ngit commit -m \"remove\" 移除文件(从Git中删除)\n\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\n\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\n\ngit stash push 将文件给push到一个临时空间中\n\ngit stash pop 将文件从临时空间pop下来\n\n---------------------------------------------------------\n\ngit remote add origin git@github.com:username/Hello-World.git\n\ngit push origin master 将本地项目给提交到服务器中\n\n-----------------------------------------------------------\n\ngit pull 本地与服务器端同步\n\n-----------------------------------------------------------------\n\ngit push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\n\ngit push origin serverfix:awesomebranch\n\n------------------------------------------------------------------\n\ngit fetch 相当于是从远程获取最新版本到本地，不会自动merge\n\ngit commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\n\ngit branch branch_0.1 master 从主分支master创建branch_0.1分支\n\ngit branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\n\ngit checkout branch_1.0/master 切换到branch_1.0/master分支\n\ndu -hs\n\ngit branch 删除远程branch\n\ngit push origin :branch_remote_name\n\ngit branch -r -d branch_remote_name\n\n-----------------------------------------------------------\n\n初始化版本库，并提交到远程服务器端\n\nmkdir WebApp\n\ncd WebApp\n\ngit init 本地初始化\n\ntouch README\n\ngit add README 添加文件\n\ngit commit -m 'first commit'\n\ngit remote add origin git@github.com:daixu/WebApp.git\n\n增加一个远程服务器端\n\n上面的命令会增加URL地址为'git@github.com:daixu/WebApp.git'，名称为origin的远程服务器库，以后提交代码的时候只需要使用 origin别名即可\n\n二、 Git 命令速查表\n\n1、常用的Git命令\n\n命令简要说明\n\ngit add添加至暂存区\n\ngit add–interactive交互式添加\n\ngit apply应用补丁\n\ngit am应用邮件格式补丁\n\ngit annotate同义词，等同于 git blame\n\ngit archive文件归档打包\n\ngit bisect二分查找\n\ngit blame文件逐行追溯\n\ngit branch分支管理\n\ngit cat-file版本库对象研究工具\n\ngit checkout检出到工作区、切换或创建分支\n\ngit cherry-pick提交拣选\n\ngit citool图形化提交，相当于 git gui 命令\n\ngit clean清除工作区未跟踪文件\n\ngit clone克隆版本库\n\ngit commit提交\n\ngit config查询和修改配置\n\ngit describe通过里程碑直观地显示提交ID\n\ngit diff差异比较\n\ngit difftool调用图形化差异比较工具\n\ngit fetch获取远程版本库的提交\n\ngit format-patch创建邮件格式的补丁文件。参见 git am 命令\n\ngit grep文件内容搜索定位工具\n\ngit gui基于Tcl/Tk的图形化工具，侧重提交等操作\n\ngit help帮助\n\ngit init版本库初始化\n\ngit init-db*同义词，等同于 git init\n\ngit log显示提交日志\n\ngit merge分支合并\n\ngit mergetool图形化冲突解决\n\ngit mv重命名\n\ngit pull拉回远程版本库的提交\n\ngit push推送至远程版本库\n\ngit rebase分支变基\n\ngit rebase–interactive交互式分支变基\n\ngit reflog分支等引用变更记录管理\n\ngit remote远程版本库管理\n\ngit repo-config*同义词，等同于 git config\n\ngit reset重置改变分支“游标”指向\n\ngit rev-parse将各种引用表示法转换为哈希值等\n\ngit revert反转提交\n\ngit rm删除文件\n\ngit show显示各种类型的对象\n\ngit stage*同义词，等同于 git add\n\ngit stash保存和恢复进度\n\ngit status显示工作区文件状态\n\ngit tag里程碑管理\n\n2、对象库操作相关命令\n\n命令简要说明\n\ngit commit-tree从树对象创建提交\n\ngit hash-object从标准输入或文件计算哈希值或创建对象\n\ngit ls-files显示工作区和暂存区文件\n\ngit ls-tree显示树对象包含的文件\n\ngit mktag读取标准输入创建一个里程碑对象\n\ngit mktree读取标准输入创建一个树对象\n\ngit read-tree读取树对象到暂存区\n\ngit update-index工作区内容注册到暂存区及暂存区管理\n\ngit unpack-file创建临时文件包含指定 blob 的内容\n\ngit write-tree从暂存区创建一个树对象\n\n3、引用操作相关命令\n\n命令简要说明\n\ngit check-ref-format检查引用名称是否符合规范\n\ngit for-each-ref引用迭代器，用于shell编程\n\ngit ls-remote显示远程版本库的引用\n\ngit name-rev将提交ID显示为友好名称\n\ngit peek-remote*过时命令，请使用 git ls-remote\n\ngit rev-list显示版本范围\n\ngit show-branch显示分支列表及拓扑关系\n\ngit show-ref显示本地引用\n\ngit symbolic-ref显示或者设置符号引用\n\ngit update-ref更新引用的指向\n\ngit verify-tag校验 GPG 签名的Tag\n\n4、版本库管理相关命令\n\n命令简要说明\n\ngit count-objects显示松散对象的数量和磁盘占用\n\ngit filter-branch版本库重构\n\ngit fsck对象库完整性检查\n\ngit fsck-objects*同义词，等同于 git fsck\n\ngit gc版本库存储优化\n\ngit index-pack从打包文件创建对应的索引文件\n\ngit lost-found*过时，请使用 git fsck –lost-found 命令\n\ngit pack-objects从标准输入读入对象ID，打包到文件\n\ngit pack-redundant查找多余的 pack 文件\n\ngit pack-refs将引用打包到 .git/packed-refs 文件中\n\ngit prune从对象库删除过期对象\n\ngit prune-packed将已经打包的松散对象删除\n\ngit relink为本地版本库中相同的对象建立硬连接\n\ngit repack将版本库未打包的松散对象打包\n\ngit show-index读取包的索引文件，显示打包文件中的内容\n\ngit unpack-objects从打包文件释放文件\n\ngit verify-pack校验对象库打包文件\n\n5、数据传输相关命令\n\n命令简要说明\n\ngit fetch-pack执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象\n\ngit receive-pack执行 git push 命令时在远程执行的命令，用于接受推送的数据\n\ngit send-pack执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据\n\ngit upload-archive执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档\n\ngit upload-pack执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传\n\n6、邮件相关命令\n\n命令简要说明\n\ngit imap-send将补丁通过 IMAP 发送\n\ngit mailinfo从邮件导出提交说明和补丁\n\ngit mailsplit将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件\n\ngit request-pull创建包含提交间差异和执行PULL操作地址的信息\n\ngit send-email发送邮件\n\n7、协议相关命令\n\n命令简要说明\n\ngit daemon实现Git协议\n\ngit http-backend实现HTTP协议的CGI程序，支持智能HTTP协议\n\ngit instaweb即时启动浏览器通过 gitweb 浏览当前版本库\n\ngit shell受限制的shell，提供仅执行Git命令的SSH访问\n\ngit update-server-info更新哑协议需要的辅助文件\n\ngit http-fetch通过HTTP协议获取版本库\n\ngit http-push通过HTTP/DAV协议推送\n\ngit remote-ext由Git命令调用，通过外部命令提供扩展协议支持\n\ngit remote-fd由Git命令调用，使用文件描述符作为协议接口\n\ngit remote-ftp由Git命令调用，提供对FTP协议的支持\n\ngit remote-ftps由Git命令调用，提供对FTPS协议的支持\n\ngit remote-http由Git命令调用，提供对HTTP协议的支持\n\ngit remote-https由Git命令调用，提供对HTTPS协议的支持\n\ngit remote-testgit协议扩展示例脚本\n\n8、版本库转换和交互相关命令\n\n命令简要说明\n\ngit archimport导入Arch版本库到Git\n\ngit bundle提交打包和解包，以便在不同版本库间传递\n\ngit cvsexportcommit将Git的一个提交作为一个CVS检出\n\ngit cvsimport导入CVS版本库到Git。或者使用 cvs2git\n\ngit cvsserverGit的CVS协议模拟器，可供CVS命令访问Git版本库\n\ngit fast-export将提交导出为 git-fast-import 格式\n\ngit fast-import其他版本库迁移至Git的通用工具\n\ngit svnGit 作为前端操作 Subversion\n\n9、合并相关的辅助命令\n\n命令简要说明\n\ngit merge-base供其他脚本调用，找到两个或多个提交最近的共同祖先\n\ngit merge-file针对文件的两个不同版本执行三向文件合并\n\ngit merge-index对index中的冲突文件调用指定的冲突解决工具\n\ngit merge-octopus合并两个以上分支。参见 git merge 的octopus合并策略\n\ngit merge-one-file由 git merge-index 调用的标准辅助程序\n\ngit merge-ours合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略\n\ngit merge-recursive针对两个分支的三向合并。参见 git merge 的recursive合并策略\n\ngit merge-resolve针对两个分支的三向合并。参见 git merge 的resolve合并策略\n\ngit merge-subtree子树合并。参见 git merge 的 subtree 合并策略\n\ngit merge-tree显式三向合并结果，不改变暂存区\n\ngit fmt-merge-msg供执行合并操作的脚本调用，用于创建一个合并提交说明\n\ngit rerere重用所记录的冲突解决方案\n\n10、 杂项\n\n命令简要说明\n\ngit bisect–helper由 git bisect 命令调用，确认二分查找进度\n\ngit check-attr显示某个文件是否设置了某个属性\n\ngit checkout-index从暂存区拷贝文件至工作区\n\ngit cherry查找没有合并到上游的提交\n\ngit diff-files比较暂存区和工作区，相当于 git diff –raw\n\ngit diff-index比较暂存区和版本库，相当于 git diff –cached –raw\n\ngit diff-tree比较两个树对象，相当于 git diff –raw A B\n\ngit difftool–helper由 git difftool 命令调用，默认要使用的差异比较工具\n\ngit get-tar-commit-id从 git archive 创建的 tar 包中提取提交ID\n\ngit gui–askpass命令 git gui 的获取用户口令输入界面\n\ngit notes提交评论管理\n\ngit patch-id补丁过滤行号和空白字符后生成补丁唯一ID\n\ngit quiltimport将Quilt补丁列表应用到当前分支\n\ngit replace提交替换\n\ngit shortlog对 git log 的汇总输出，适合于产品发布说明\n\ngit stripspace删除空行，供其他脚本调用\n\ngit submodule子模组管理\n\ngit tar-tree过时命令，请使用 git archive\n\ngit var显示 Git 环境变量\n\ngit web–browse启动浏览器以查看目录或文件\n\ngit whatchanged显示提交历史及每次提交的改动\n\ngit-mergetool–lib包含于其他脚本中，提供合并/差异比较工具的选择和执行\n\ngit-parse-remote包含于其他脚本中，提供操作远程版本库的函数\n\ngit-sh-setup包含于其他脚本中，提供 shell 编程的函数库\n\n下面脚本之家小编特为大家分享一个图片版的\n\nGit 常用命令速查表。点击查看大图。\n\nGit 常用命令速查表\nGit命令参考手册(文本版)\n\ngit init                                                  # 初始化本地git仓库（创建新仓库）\n\ngit config --global user.name \"xxx\"                       # 配置用户名\n\ngit config --global user.email \"xxx@xxx.com\"              # 配置邮件\n\ngit config --global color.ui true                         # git status等命令自动着色\n\ngit config --global color.status auto\n\ngit config --global color.diff auto\n\ngit config --global color.branch auto\n\ngit config --global color.interactive auto\n\ngit clone git+ssh://git@192.168.53.168/VT.git             # clone远程仓库\n\ngit status                                                # 查看当前版本状态（是否修改）\n\ngit add xyz                                               # 添加xyz文件至index\n\ngit add .                                                 # 增加当前子目录下所有更改过的文件至index\n\ngit commit -m 'xxx'                                       # 提交\n\ngit commit --amend -m 'xxx'                               # 合并上一次提交（用于反复修改）\n\ngit commit -am 'xxx'                                      # 将add和commit合为一步\n\ngit rm xxx                                                # 删除index中的文件\n\ngit rm -r *                                               # 递归删除\n\ngit log                                                   # 显示提交日志\n\ngit log -1                                                # 显示1行日志 -n为n行\n\ngit log -5\n\ngit log --stat                                            # 显示提交日志及相关变动文件\n\ngit log -p -m\n\ngit show dfb02e6e4f2f7b573337763e5c0013802e392818         # 显示某个提交的详细内容\n\ngit show dfb02                                            # 可只用commitid的前几位\n\ngit show HEAD                                             # 显示HEAD提交日志\n\ngit show HEAD^                                            # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本\n\ngit tag                                                   # 显示已存在的tag\n\ngit tag -a v2.0 -m 'xxx'                                  # 增加v2.0的tag\n\ngit show v2.0                                             # 显示v2.0的日志及详细内容\n\ngit log v2.0                                              # 显示v2.0的日志\n\ngit diff                                                  # 显示所有未添加至index的变更\n\ngit diff --cached                                         # 显示所有已添加index但还未commit的变更\n\ngit diff HEAD^                                            # 比较与上一个版本的差异\n\ngit diff HEAD -- ./lib                                    # 比较与HEAD版本lib目录的差异\n\ngit diff origin/master..master                            # 比较远程分支master上有本地分支master上没有的\n\ngit diff origin/master..master --stat                     # 只显示差异的文件，不显示具体内容\n\ngit remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）\n\ngit branch                                                # 显示本地分支\n\ngit branch --contains 50089                               # 显示包含提交50089的分支\n\ngit branch -a                                             # 显示所有分支\n\ngit branch -r                                             # 显示所有原创分支\n\ngit branch --merged                                       # 显示所有已合并到当前分支的分支\n\ngit branch --no-merged                                    # 显示所有未合并到当前分支的分支\n\ngit branch -m master master_copy                          # 本地分支改名\n\ngit checkout -b master_copy                               # 从当前分支创建新分支master_copy并检出\n\ngit checkout -b master master_copy                        # 上面的完整版\n\ngit checkout features/performance                         # 检出已存在的features/performance分支\n\ngit checkout --track hotfixes/BJVEP933                    # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支\n\ngit checkout v2.0                                         # 检出版本v2.0\n\ngit checkout -b devel origin/develop                      # 从远程分支develop创建新本地分支devel并检出\n\ngit checkout -- README                                    # 检出head版本的README文件（可用于修改错误回退）\n\ngit merge origin/master                                   # 合并远程master分支至当前分支\n\ngit cherry-pick ff44785404a8e                             # 合并提交ff44785404a8e的修改\n\ngit push origin master                                    # 将当前分支push到远程master分支\n\ngit push origin :hotfixes/BJVEP933                        # 删除远程仓库的hotfixes/BJVEP933分支\n\ngit push --tags                                           # 把所有tag推送到远程仓库\n\ngit fetch                                                 # 获取所有远程分支（不更新本地分支，另需merge）\n\ngit fetch --prune                                         # 获取所有原创分支并清除服务器上已删掉的分支\n\ngit pull origin master                                    # 获取远程分支master并merge到当前分支\n\ngit mv README README2                                     # 重命名文件README为README2\n\ngit reset --hard HEAD                                     # 将当前版本重置为HEAD（通常用于merge失败回退）\n\ngit rebase\n\ngit branch -d hotfixes/BJVEP933                           # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）\n\ngit branch -D hotfixes/BJVEP933                           # 强制删除分支hotfixes/BJVEP933\n\ngit ls-files                                              # 列出git index包含的文件\n\ngit show-branch                                           # 图示当前分支历史\n\ngit show-branch --all                                     # 图示所有分支历史\n\ngit whatchanged                                           # 显示提交历史对应的文件修改\n\ngit revert dfb02e6e4f2f7b573337763e5c0013802e392818       # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818\n\ngit ls-tree HEAD                                          # 内部命令：显示某个git对象\n\ngit rev-parse v2.0                                        # 内部命令：显示某个ref对于的SHA1 HASH\n\ngit reflog                                                # 显示所有提交，包括孤立节点\n\ngit show HEAD@{5}\n\ngit show master@{yesterday}                               # 显示master分支昨天的状态\n\ngit log --pretty=format:'%h %s' --graph                   # 图示提交日志\n\ngit show HEAD~3\n\ngit show -s --pretty=raw 2be7fcb476\n\ngit stash                                                 # 暂存当前修改，将所有至为HEAD状态\n\ngit stash list                                            # 查看所有暂存\n\ngit stash show -p stash@{0}                               # 参考第一次暂存\n\ngit stash apply stash@{0}                                 # 应用第一次暂存\n\ngit grep \"delete from\"                                    # 文件中搜索文本“delete from”\n\ngit grep -e '#define' --and -e SORT_DIRENT\n\ngit gc\n\ngit fsck\n\nGit是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。\n\nGit常用操作命令：\n\n1) 远程仓库相关命令\n\n检出仓库：$ git clone git://github.com/jquery/jquery.git\n\n查看远程仓库：$ git remote -v\n\n添加远程仓库：$ git remote add [name] [url]\n\n删除远程仓库：$ git remote rm [name]\n\n修改远程仓库：$ git remote set-url --push [name] [newUrl]\n\n拉取远程仓库：$ git pull [remoteName] [localBranchName]\n\n推送远程仓库：$ git push [remoteName] [localBranchName]\n\n\n\n*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：\n\n$git push origin test:master         // 提交本地test分支作为远程的master分支\n\n$git push origin test:test              // 提交本地test分支作为远程的test分支\n\n\n\n2）分支(branch)操作相关命令\n\n查看本地分支：$ git branch\n\n查看远程分支：$ git branch -r\n\n创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支\n\n切换分支：$ git checkout [name]\n\n创建新分支并立即切换到新分支：$ git checkout -b [name]\n\n删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项\n\n合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并\n\n创建远程分支(本地分支push到远程)：$ git push origin [name]\n\n删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] \n\n\n\n*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)\n\n$git symbolic-ref HEAD refs/heads/[name]\n\n$rm .git/index\n\n$git clean -fdx\n\n\n\n3）版本(tag)操作相关命令\n\n查看版本：$ git tag\n\n创建版本：$ git tag [name]\n\n删除版本：$ git tag -d [name]\n\n查看远程版本：$ git tag -r\n\n创建远程版本(本地版本push到远程)：$ git push origin [name]\n\n删除远程版本：$ git push origin :refs/tags/[name]\n\n合并远程仓库的tag到本地：$ git pull origin --tags\n\n上传本地tag到远程仓库：$ git push origin --tags\n\n创建带注释的tag：$ git tag -a [name] -m 'yourMessage'\n\n\n\n4) 子模块(submodule)相关操作命令\n\n添加子模块：$ git submodule add [url] [path]\n\n   如：$git submodule add git://github.com/soberh/ui-libs.git src/main/webapp/ui-libs\n\n初始化子模块：$ git submodule init  ----只在首次检出仓库时运行一次就行\n\n更新子模块：$ git submodule update ----每次更新或切换分支后都需要运行一下\n\n删除子模块：（分4步走哦）\n\n 1) $ git rm --cached [path]\n\n 2) 编辑“.gitmodules”文件，将子模块的相关配置节点删除掉\n\n 3) 编辑“ .git/config”文件，将子模块的相关配置节点删除掉\n\n 4) 手动删除子模块残留的目录\n\n\n\n5）忽略一些文件、文件夹不提交\n\n在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如\n\ntarget\n\nbin\n\n*.db\n\n\n\n=====================\n\nGit 常用命令\n\ngit branch 查看本地所有分支\n\ngit status 查看当前状态\n\ngit commit 提交\n\ngit branch -a 查看所有的分支\n\ngit branch -r 查看本地所有分支\n\ngit commit -am \"init\" 提交并且加注释\n\ngit remote add origin git@192.168.1.119:ndshow\n\ngit push origin master 将文件给推到服务器上\n\ngit remote show origin 显示远程库origin里的资源\n\ngit push origin master:develop\n\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联\n\ngit checkout --track origin/dev 切换到远程dev分支\n\ngit branch -D master develop 删除本地库develop\n\ngit checkout -b dev 建立一个新的本地分支dev\n\ngit merge origin/dev 将分支dev与当前分支进行合并\n\ngit checkout dev 切换到本地dev分支\n\ngit remote show 查看远程库\n\ngit add .\n\ngit rm 文件名(包括路径) 从git中删除指定文件\n\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\n\ngit config --list 看所有用户\n\ngit ls-files 看已经被提交的\n\ngit rm [file name] 删除一个文件\n\ngit commit -a 提交当前repos的所有的改变\n\ngit add [file name] 添加一个文件到git index\n\ngit commit -v 当你用－v参数的时候可以看commit的差异\n\ngit commit -m \"This is the message describing the commit\" 添加commit信息\n\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\n\ngit commit -a -v 一般提交命令\n\ngit log 看你commit的日志\n\ngit diff 查看尚未暂存的更新\n\ngit rm a.a 移除文件(从暂存区和工作区中删除)\n\ngit rm --cached a.a 移除文件(只从暂存区中删除)\n\ngit commit -m \"remove\" 移除文件(从Git中删除)\n\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\n\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\n\ngit stash push 将文件给push到一个临时空间中\n\ngit stash pop 将文件从临时空间pop下来\n\n---------------------------------------------------------\n\ngit remote add origin git@github.com:username/Hello-World.git\n\ngit push origin master 将本地项目给提交到服务器中\n\n-----------------------------------------------------------\n\ngit pull 本地与服务器端同步\n\n-----------------------------------------------------------------\n\ngit push (远程仓库名) (分支名) 将本地分支推送到服务器上去。\n\ngit push origin serverfix:awesomebranch\n\n------------------------------------------------------------------\n\ngit fetch 相当于是从远程获取最新版本到本地，不会自动merge\n\ngit commit -a -m \"log_message\" (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：\n\ngit branch branch_0.1 master 从主分支master创建branch_0.1分支\n\ngit branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0\n\ngit checkout branch_1.0/master 切换到branch_1.0/master分支\n\ndu -hs\n\n-----------------------------------------------------------\n\nmkdir WebApp\n\ncd WebApp\n\ngit init\n\ntouch README\n\ngit add README\n\ngit commit -m 'first commit'\n\ngit remote add origin git@github.com:xiayk/test.git\n\ngit push -u origin master\n```\n","tags":["git"],"categories":["git"]},{"title":"微信小程序-Java (模板消息)","url":"/2019/08/25/微信小程序-java-模板消息/","content":"### 微信小程序模板消息\n- 请求地址(POST)\n\t`https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=TOKEN`\n- 请求参数\n\t```json\n    {\n    \t\"template_id\": \"模板Id (XXXX)\",\n        \"touser\": \"接收用户的openId (XXXX)\",\n        \"page\": \"点击模板消息跳转页面 (pages/index?data=XX)\",\n        \"data\": \n        {\n        \t\"keyword1\": {\"value\": \"\"},\n            \"keyword2\": {\"value\": \"\"},\n            \"keyword3\": {\"value\": \"\"},\n            ...\n        }\n    }\n    ```\n\n#### 获取access_token\n```java\n/**\n * 获取微信access_token\n * @return\ttoken\n */\npublic String getToken(){\n        String token;\n        try {\n        \t//获取redis中token\n            token = redisTemplate.opsForValue().get(\"access_token\");\n            if (token == null) {\n                throw new Exception();\n            }\n        }catch (Exception e){\n        \t//重新获取token\n            String url = String.format(\"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=%s&secret=%s\",appId, appsecret);\n            token = JSONObject.parseObject(Utils.doGet(url)).getString(\"access_token\");\n           //存入redis  7200s 2小时过期 redisTemplate.opsForValue().set(\"access_token\", token, 7200, TimeUnit.SECONDS);\n        }\n        return token;\n    }\n```\n\n#### 发送模板消息\n```java\n//请求地址\nString url = String.format(\"https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=%s\", token);\n\n//请求参数\nJSONObject jsonObject = new JSONObject();\njsonObject.put(\"template_id\", templateId);\njsonObject.put(\"form_id\", formId);\njsonObject.put(\"touser\", toUser);\njsonObject.put(\"page\", pagePath);\n\n//data\nJSONObject jsonData = new JSONObject();\nJSONObject json1 = new JSONObjectect();\njson1.put(\"value\", \"\");\njsonData.put(\"keyword1\", json1);\nJSONObject json2 = new JSONObject();\njson2.put(\"value\", \"\");\njsonData.put(\"keyword2\", json2);\nJSONObject json3 = new JSONObject();\njson3.put(\"value\", \"\");\njsonData.put(\"keyword3\", json3);\nJSONObject json4 = new JSONObject();\njson4.put(\"value\", \"\");\njsonData.put(\"keyword4\", json4);\n\njsonObject.put(\"data\", jsonData);\n\ndoPost(jsonObject.toJSONString(), url);\n```","tags":["Java","小程序"],"categories":["小程序","Java"]},{"title":"Springboot集成jwt实现token验证","url":"/2019/06/28/springboot集成jwt实现token验证/","content":"#### 什么是JWT\nJson web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。\n\n#### JWT请求流程\n<image src=\"http://file.xiayk.com/4630295-7df0d10fcffe831b.png\"/>\n\n1. 用户使用账号和面发出post请求；\n2. 服务器使用私钥创建一个jwt；\n3. 服务器返回这个jwt给浏览器；\n4. 浏览器将该jwt串在请求头中像服务器发送请求；\n5. 服务器验证该jwt；\n6. 返回响应的资源给浏览器。\n\n#### 代码\nJwtConfig.java\n创建token  存入redis 设置token过时间, 如果在规定时间内没有验证token redis就会删除token\n```java\n/**\n* 根据微信用户登陆信息创建 token\n* 注 : 这里的token会被缓存到redis中,用作为二次验证\n* redis里面缓存的时间应该和jwt token的过期时间设置相同\n*\n* @param wxRes 微信用户信息\n* @return 返回 jwt token\n*/\npublic String createTokenByWxAccount(WxRes wxRes) {\n        String jwtId = UUID.randomUUID().toString();                 //JWT 随机ID,做为验证的key\n        //1 . 加密算法进行签名得到token\n        Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);\n        String token = JWT.create()\n                .withClaim(\"wxOpenId\", wxRes.getWxopenid())\n                .withClaim(\"sessionKey\", wxRes.getSessionkey())\n                .withClaim(\"jwt-id\", jwtId)\n                .withExpiresAt(new Date(System.currentTimeMillis() + expire_time*1000))  //JWT 配置过期时间的正确姿势\n                .sign(algorithm);\n        //2 . Redis缓存JWT, 注 : 请和JWT过期时间一致\n        redisTemplate.opsForValue().set(\"JWT-SESSION-\" + jwtId, token, expire_time, TimeUnit.SECONDS);\n        return token;\n    }\n```\n验证token redis给token续期\n```java\n /**\n  * 校验token是否正确\n  * 1 . 根据token解密，解密出jwt-id , 先从redis中查找出redisToken，匹配是否相同\n  * 2 . 然后再对redisToken进行解密，解密成功则 继续流程 和 进行token续期\n  *\n  * @param token 密钥\n  * @return 返回是否校验通过\n  */\n public boolean verifyToken(String token) {\n     try {\n         //1 . 根据token解密，解密出jwt-id , 先从redis中查找出redisToken，匹配是否相同\n         String redisToken = redisTemplate.opsForValue().get(\"JWT-SESSION-\" + getJwtIdByToken(token));\n          if (!redisToken.equals(token)) return false;\n          //2 . 得到算法相同的JWTVerifier\n          Algorithm algorithm = Algorithm.HMAC256(SECRET_KEY);\n          JWTVerifier verifier = JWT.require(algorithm)\n                  .withClaim(\"wxOpenId\", getWxOpenIdByToken(redisToken))\n                  .withClaim(\"sessionKey\", getSessionKeyByToken(redisToken))\n                  .withClaim(\"jwt-id\", getJwtIdByToken(redisToken))\n                  .acceptExpiresAt(System.currentTimeMillis() + expire_time*1000 )  //JWT 正确的配置续期姿势\n                  .build();\n          //3 . 验证token\n          verifier.verify(redisToken);\n          //4 . Redis缓存JWT续期\n          redisTemplate.opsForValue().set(\"JWT-SESSION-\" + getJwtIdByToken(token), redisToken, expire_time, TimeUnit.SECONDS);\n          return true;\n      } catch (Exception e) { //捕捉到任何异常都视为校验失败\n          return false;\n      }\n  }\n```\n\n拦截器\n```java\n/**\n * 拦截器  token\n * @ClassName LoginInterceptor\n * @Author XiaYk\n * @Date 2019-06-23 22:06\n * @Version 1.0\n */\npublic class LoginInterceptor implements HandlerInterceptor {\n\n    private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);\n\n    @Autowired\n    private WxResService service;\n\n    private String notloginRes = JSONObject.toJSONString(new RestResult(false, -1, \"\", \"未登录\"));\n    private String errRes = JSONObject.toJSONString(new RestResult(false, -2, \"\", \"登录过期, 请重新登录\"));\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        response.setCharacterEncoding(\"UTF-8\");\n        response.setContentType(\"application/json; charset=utf-8\");\n        response.setHeader(\"Access-control-Allow-Origin\", request.getHeader(\"Origin\"));\n        response.setHeader(\"Access-Control-Allow-Methods\", \"GET,POST,OPTIONS,PUT,DELETE\");\n        response.setHeader(\"Access-Control-Allow-Headers\", request.getHeader(\"Access-Control-Request-Headers\"));\n        // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态\n        if (request.getMethod().equals(RequestMethod.OPTIONS.name())) {\n            response.setStatus(HttpStatus.OK.value());\n            return false;\n        }\n        //获取访问URL\n        String url = request.getRequestURL().toString();\n        String token = request.getHeader(\"XWEB_TOKEN\");\n\n        if (token == null){\n            PrintWriter out = response.getWriter();\n            out.append(notloginRes);\n            return false;\n        }\n\n        if (service.verifyToken(token)){\n            logger.info(\"url ====> {}  token ====> {}\", url, token);\n            return true;\n        }else {\n            logger.info(\"token 过期\");\n            PrintWriter out = response.getWriter();\n            out.println(errRes);\n            return false;\n        }\n    }\n\n    /**\n     * // 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）\n     * @param request\n     * @param response\n     * @param handler\n     * @param modelAndView\n     * @throws Exception\n     */\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {\n\n    }\n\n    /**\n     * 在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作）\n     * @param request\n     * @param response\n     * @param handler\n     * @param ex\n     * @throws Exception\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {\n\n    }\n}\n```\n```java\n/**\n * @ClassName MyWebAppConfigurer\n * @Author XiaYk\n * @Date 2019-06-24 00:21\n * @Version 1.0\n */\n@Configuration\npublic class MyWebAppConfigurer extends WebMvcConfigurationSupport {\n\n    @Bean\n    LoginInterceptor interceptor() {\n        return new LoginInterceptor();\n    }\n\n    @Override\n    protected void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        super.configureMessageConverters(converters);\n    }\n\n    @Override\n    protected void addInterceptors(InterceptorRegistry registry) {\n        super.addInterceptors(registry);\n        registry.addInterceptor(interceptor()).addPathPatterns(\"/wx/**\")//拦截\n                .excludePathPatterns(\"/wx/login\").excludePathPatterns(\"/getData\");//开放\n    }\n}\n```\n然后在controller调用 获取token 返回给前端\n```java\n/**\n * 登录\n * @param code\n * @return\n */\n@PostMapping(\"login\")\npublic RestResult wxLogin(@RequestParam(\"code\") String code){\n    String token = wxResService.selectByCode(code);\n    Map<String, Object> map = new HashMap<>();\n    map.put(\"token\", token);\n    map.put(\"username\", \"XiaYk\");\n    return new RestResult(true, 200, map, \"\");\n}\n```\npom.xml\n```xml\n<!--springboot-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n\n<!--redis-->\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n\n<!--JWT-->\n<dependency>\n    <groupId>com.auth0</groupId>\n    <artifactId>java-jwt</artifactId>\n    <version>3.4.1</version>\n</dependency>\n```","tags":["springboot","java","jwt"],"categories":["java"]},{"title":"微信小程序-Java (登录)","url":"/2019/05/10/微信小程序-Java-登录/","content":"\n[微信官方文档](https://developers.weixin.qq.com/miniprogram/dev/api/wx.login.html)\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\n\n\n### 一,Java后端\n接收小程序端传过来的code;\n```java\n\t/**\n     * 微信登录\n     * @param code\n     * @return\n     */\n    @RequestMapping(value = \"/login\")\n    public RestResult wxlogin(@RequestParam(\"code\") String code){\n\n        //获取openid\n        JSONObject jsonObject = WxUtil.getSessionKeyOropenid(code);\n        String openid = jsonObject.get(\"openid\").toString();\n        System.out.println(code);\n        WxUserInfoKey wxUserInfoKey = new WxUserInfoKey();\n        wxUserInfoKey.setOpenid(openid);\n        WxUserInfo info = wxUserInfoService.selectByPrimaryKey(wxUserInfoKey);\n\n        if (info == null){\n            throw new MyException(-1, \"未绑定账户\");\n        }\n\n        UserKey key = new UserKey();\n        key.setUsername(info.getUsername());\n        User user = userService.selectByPrimaryKey(key);\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword());\n        subject.login(token);\n        return new RestResult(true,0,info,\"mes: ok\");\n\n    }\n```\n\n\nWeChat工具类/获取openid\n```java\npackage com.xiayk.utils;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.codehaus.xfire.util.Base64;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.UnsupportedEncodingException;\nimport java.security.*;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.ResourceBundle;\n\n/**\n * @ClassName WxUtil\n * @Author XiaYk\n * @Date 2019-04-26 19:08\n * @Version 1.0\n */\npublic class WxUtil {\n    Logger log = LoggerFactory.getLogger(this.getClass());\n\n    /**\n     * 获取微信小程序 session_key 和 openid\n     *\n     * @author zhy\n     * @param code 调用微信登陆返回的Code\n     * @return\n     */\n    public static JSONObject getSessionKeyOropenid(String wxCode){\n        String requestUrl = \"https://api.weixin.qq.com/sns/jscode2session\";//resource.getString(\"url\"); //请求地址 https://api.weixin.qq.com/sns/jscode2session\n        Map<String,String> requestUrlParam = new HashMap<>();\n        requestUrlParam.put(\"appid\", \"*************\"); //开发者设置中的appId\n        requestUrlParam.put(\"secret\", \"***********************\"); //开发者设置中的appSecret\n        requestUrlParam.put(\"js_code\", wxCode); //小程序调用wx.login返回的code\n        requestUrlParam.put(\"grant_type\", \"authorization_code\");  //默认参数\n\n        //发送post请求读取调用微信 https://api.weixin.qq.com/sns/jscode2session 接口获取openid用户唯一标识\n        JSONObject jsonObject = JSON.parseObject(UrlUtil.sendPost(requestUrl, requestUrlParam));\n        return jsonObject;\n    }\n\n    /**\n     * 解密用户敏感数据获取用户信息\n     *\n     * @author zhy\n     * @param sessionKey 数据进行加密签名的密钥\n     * @param encryptedData 包括敏感数据在内的完整用户信息的加密数据\n     * @param iv 加密算法的初始向量\n     * @return\n     */\n    public static JSONObject getUserInfo(String encryptedData,String sessionKey,String iv){\n        // 被加密的数据\n        byte[] dataByte = Base64.decode(encryptedData);\n        // 加密秘钥\n        byte[] keyByte = Base64.decode(sessionKey);\n        // 偏移量\n        byte[] ivByte = Base64.decode(iv);\n        try {\n            // 如果密钥不足16位，那么就补足. 这个if 中的内容很重要\n            int base = 16;\n            if (keyByte.length % base != 0) {\n                int groups = keyByte.length / base + (keyByte.length % base != 0 ? 1 : 0);\n                byte[] temp = new byte[groups * base];\n                Arrays.fill(temp, (byte) 0);\n                System.arraycopy(keyByte, 0, temp, 0, keyByte.length);\n                keyByte = temp;\n            }\n            // 初始化\n            Security.addProvider(new BouncyCastleProvider());\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");\n            SecretKeySpec spec = new SecretKeySpec(keyByte, \"AES\");\n            AlgorithmParameters parameters = AlgorithmParameters.getInstance(\"AES\");\n            parameters.init(new IvParameterSpec(ivByte));\n            cipher.init(Cipher.DECRYPT_MODE, spec, parameters);// 初始化\n            byte[] resultByte = cipher.doFinal(dataByte);\n            if (null != resultByte && resultByte.length > 0) {\n                String result = new String(resultByte, \"UTF-8\");\n                return JSON.parseObject(result);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            } catch (NoSuchPaddingException e) {\n        } catch (InvalidParameterSpecException e) {\n        } catch (IllegalBlockSizeException e) {\n        } catch (BadPaddingException e) {\n        } catch (UnsupportedEncodingException e) {\n        } catch (InvalidKeyException e) {\n        } catch (InvalidAlgorithmParameterException e) {\n        } catch (NoSuchProviderException e) {\n        }\n        return null;\n    }\n}\n\n```\n\n\n\n","tags":["Java","springboot","wechat","小程序"],"categories":["java"]},{"title":"Linux下Nginx+Tomcat整合配置","url":"/2019/05/05/Linux下Nginx-Tomcat整合配置/","content":"\n#### 一, 安装jdk和tomcat\n1, jdk安装 \njdk的话,我直接用的yum安装的,简单方便\n```\nyum list java-1.8*\nyum install java-1.8*\n```\n安装完检查jdk\n```\njava -version\n```\n安装成功后就可以开始安装tomcat了\n\n2, tomcat安装\n先去tomcat官网  找到自己需要的版本 下载那个`tar.gz`后缀的\n我用的[tomcat官网](http://tomcat.apache.org)\n然后在服务器上\n```\n//下载\nwget http://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.40/bin/apache-tomcat-8.5.40.tar.gz\n//解压\ntar -zxvf apache-tomcat-8.5.40.tar.gz\n```\n下载完解压然后测试一下\n```\n//运行\n./apache-tomcat-8.5.40.tar.gz/bin/start.sh\n```\n访问一下`ip:8080`如能成功显示tomcat页面就行了\n如不能访问,先看一下tomcat日志\n```\ncat apache-tomcat-8.5.40/logs/catalina.out\n```\n一般应该是没问题的, 看一下8080端口是否开放\n```\nps -ef| grep tomcat\n```\n这个可以看tomcat进程\n没问题的话  就可以开始下一步了\n\n#### 二, Nginx安装和配置\nnginx我也是刚开始来了解, 可能配置得不是很专业\n[nginx官网](http://nginx.org)\n```\n//下载\nwget http://nginx.org/download/nginx-1.14.2.tar.gz\n//解压\ntar -zxvf nginx-1.14.2.tar.gz\n```\n80端口配置\n```\nserver {\n        listen       80;\n        server_name  xiayk.cn; #域名\n        index index.html index.htm;\n        location / {\n           root   html; #站点目录\n        }\n    }\n    server {\n        listen       80;\n        server_name  api.xiayk.cn;\n        index index.html index.htm index.jsp;\n        location / {\n           proxy_pass http://127.0.0.1:8080/api;\n        }\n    }\n```\n\n443端口配置\n```\nserver {\n     listen 443;\n     server_name xiayk.cn; #填写绑定证书的域名\n     ssl on;\n     ssl_certificate /usr/local/nginx/conf/ssl/www/1_xiayk.cn_bundle.crt;\n     ssl_certificate_key /usr/local/nginx/conf/ssl/www/2_xiayk.cn.key;\n     ssl_session_timeout 5m;\n     ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置\n     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;\n     ssl_prefer_server_ciphers on;\n     location / {\n         root   html; #站点目录\n         index  index.html index.htm;\n     }\n   }\n```\n\n\n\n\n\n","tags":["Linux","nginx","tomcat"],"categories":["Linux"]},{"title":"我的第一篇博客","url":"/2019/05/02/我的第一篇博客/"},{"title":"Hello World","url":"/2019/05/02/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]